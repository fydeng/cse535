import re
import time
import sys
import collections
import logging
from init import *
import random

def parse_config(input_str):
    input_str = input_str.replace(' ','')
    strs = input_str.split(',')
    if int(strs[0])!= 0:
       	retrans = True
       	print ('Retransmission enabled')
    else:
       	reTrans = False
    retrans_interval = int(strs[1])
    print ('Timeout is:',retrans_interval)
    retrans_time = int(strs[2])
    print ('nRetrans is:',retrans_time)
    if int(strs[3])!= 0:
    	ifRandom = True
    	print ("Random request enabled")
    else:
    	ifRandom = False
    time_delay = int(strs[4])
    return [retrans, retrans_interval, retrans_time, ifRandom, time_delay]

def parse_server(input_str):
		input_str =input_str.strip()
		input_str =input_str.replace(' ','')
		str =input_str.split(',')
		bankName = int(str[0])
		serverIP = str[1]
		startup_delay = int(str[2])
		life_time = str[3]
		message_loss = int(str[4])
		return [bankName,serverIP, startup_delay,life_time,message_loss]

def parse_client(input_str):
		input_str = input_str.replace(' ','')
		str = input_str.split(',')
		bankName = str[0]
		account_no = str[1]
		clientIP = str[2]
		return [bankName,account_no,clientIP]

def parse_req(input_str):
    input_str = input_str.replace(' ','')
    input_str = re.sub('[()]','',input_str)
    strs = input_str.split(',')
    if(strs[0]=='getBalance'):
        reqtype = ReqType.Query
    elif(strs[0]=='deposit'):
        reqtype = ReqType.Deposit
    elif(strs[0]=='withdraw'):
        reqtype = ReqType.Withdraw
    else:
        reqtype = ReqType.Transfer
    reqID = strs[1]
    account_num = strs[2]
    if reqtype == ReqType.Query:
        amount = 0
    else:
        amount = strs[3]
    return [reqID,reqtype,account_num,amount]

def parse_randomReq(input_str):
	input_str = input_str.strip()
	input_str = input_str.replace(' ','')
	input_str = re.sub('[()]','',input_str)
	strs = input_str.split(',')
	seed_num = int(strs[0])
	num_req = int(strs[1])
	prob_query = float(strs[2])
	prob_deposit = float(strs[3])
	prob_withdraw = float(strs[4])
	prob_transfer = float(strs[5])
	return [seed_num, num_req, prob_query, prob_deposit, prob_withdraw, prob_transfer]

class Master(process):
	def setup(srvDic, cliDic, filename,waitList):
		self.timesheet ={}
		self.srvDict = srvDic
		self.cliDict = cliDic
		self.filename = filename
		self.waitList = waitList
		self.filename = filename
		setup_logfile(self.filename)

	def setup_logfile(filename):
		rootlog = logging.getLogger('')
		filelvl = logging.INFO
		fh = logging.FileHandler(filename)
		formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
		fh.setFormatter(formatter)
		fh.setLevel(filelvl)
		rootlog._filelvl = filelvl
		rootlog.addHandler(fh)	

	def receive(msg=("PING",ping), from_=src_id):
		cur_ticks = time.time()
		#time_recv = logical_clock()
		flag = False
		output("Received PING from: "+ str(ping.serverIP))
		bankname = ping.bankName
		new_tail = None
		for item in  self.srvDict[bankname]:
			if ping.serverIP == item[3]:
				flag = True
				self.timesheet.update({(ping.serverIP,ping.bankName):cur_ticks})
			else:
				pass
		if flag == False:
			for item in self.waitList:
				if ping.serverIP == item[4]:
					new_tail = item
					output("Server requested extending chain, adding new server "+str(item[4])+" to srvDic")
					self.srvDict[item[0]].append([item[1],item[2],item[3],item[4]])
					self.waitList.remove(item)
					flush_srvDict(bankname)
					self.timesheet.update({(ping.serverIP,ping.bankName):cur_ticks})
					output("The current srvDic after chain extension is: "+ str(self.srvDict))
		
		if new_tail != None:
			infoCli(bankname,"tail",new_tail[1])
			for item in self.srvDict[bankname]:
				if item[2] == new_tail[1]:
					send(("extendChain",item[2]),to = item[0])
				if item[0] == new_tail[1]:
					send(("new_server_join", item[1]), to = item[0])
			output("Server notification has been sent")

	def flush_srvDict(bankname):
		for i, item in enumerate(self.srvDict[bankname]):
			if len(self.srvDict[bankname]) == 1:
				item[1] = None
				item[2] = None
				return
			if i == 0:
				item[1] = None
				item[2] = srvDict[bankname][i+1][0]
				continue
			elif i == len(srvDict[bankname]) - 1:
				item[2] = None
				item[1] = srvDict[bankname][i-1][0]
			else:
				item[1] = srvDict[bankname][i-1][0]
				item[2] = srvDict[bankname][i+1][0]

	def infoCli(bankName,type,newSrv):
		for cli in self.cliDict[str(bankName)]:
			if type == "head":
				send(("newHead",newSrv),to = cli)
			elif type == "tail":
				send(("newTail",newSrv),to = cli)
			elif type == "srvFail":
				send(("srvFail",newSrv),to = cli)
		#output("Client notification has been sent")

	def updateSrvInfo(srv):
		port = srv[0]
		bankName = srv[1]
		for item in self.srvDict[bankName]:
			if port == item[3]:		#find the failed server in srvDict
				prev = item[1]
				next = item[2]
				self.srvDict[bankName].remove(item)
				flush_srvDict(bankName)
				if prev == None:	#the failed item is head
					infoCli(bankName,"head",next)
				if next == None:	#the failed item is tail
					infoCli(bankName,"tail",prev)
					output("Sending new tail notification to client!")
				elif prev != None and next != None:
					infoCli(bankName,"srvFail",None)
					output("Sending server fail notification to client!")
		for item in self.srvDict[bankName]:
			if item[0] == prev or item[0] == next:
				send(("srvFail",(item[1],item[2])),to = item[0])
				output("Sending server fail notification to server!")
			else:
				pass

	def checkSrv():
		cur_ticks = time.time()
		#time_chec = logical_clock()
		#output('Current time is ' +  str(cur_ticks))
		output(self.timesheet)
		failedSrv =[]
		for key in timesheet.keys():
			if cur_ticks - timesheet.get(key) > 5:
				output("Master has detected that Server "+ str(key[0])+" has failed!")
				failedSrv.append(key)
		for srv in failedSrv:
			del timesheet[srv]
			updateSrvInfo(srv)
			#output("Server notification has been sent")
		
	def main():
		output('Master  '+ str(self.id) +'  has started.')
		output("Server Dictory Stored in Master: "+ str(self.srvDict))
		output("Client Dictory Stored in Master: "+ str(self.cliDict))
		output("Server Waitinglist Stored in Master: "+ str(self.waitList))

		while(True):
			if(await(False)):
				pass
			elif(timeout(5)):
				checkSrv()
	

class Server(process):
	def setup(bankName, serverIP, startup_delay, life_time, message_loss, prev, next, master, filename):
		self.bankName = bankName
		self.serverIP = serverIP
		self.startup_delay =startup_delay
		self.life_time = int(life_time)
		self.message_loss = message_loss
		self.prev =prev
		self.next = next
		self.master =master
		self.sentTrans = []
		self.procTrans = {}
		self.AccountInfo = {}
		self.filename = filename
		self.recTimes = 0
		setup_logfile(self.filename)

	def setup_logfile(filename):
		rootlog = logging.getLogger('')
		filelvl = logging.INFO
		fh = logging.FileHandler(filename)
		formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
		fh.setFormatter(formatter)
		fh.setLevel(filelvl)
		rootlog._filelvl = filelvl
		rootlog.addHandler(fh)	

	def proc_balance(ack):
		outcome = Outcome.Processed
		if self.AccountInfo.get(ack.account_num) == None:
			cur_balance = 0
		else:
			cur_balance = self.AccountInfo[ack.account_num]
		if self.procTrans.get(ack.reqID) != None:
			if self.procTrans[ack.reqID].reqtype != ack.reqtype:
				outcome = Outcome.InconsistentWithHistory
			else:
				pass
			new_balance = cur_balance
		else:
			if (ack.reqtype == ReqType.Query):
				new_balance = cur_balance
			elif (ack.reqtype == ReqType.Deposit):
				new_balance = cur_balance + ack.amount
			elif (ack.reqtype == ReqType.Withdraw):
				if (cur_balance - ack.amount < 0):
					new_balance = cur_balance
					outcome = Outcome.InsufficientFunds
				else:
					new_balance = cur_balance - ack.amount;
		AccountInfo.update({ack.account_num:new_balance})		
		return [new_balance, outcome]

	def update_procTrans(reqID):
		count_clear = 0
		len_sentTrans = len(self.sentTrans)
		del_list = []
		for i in range(len_sentTrans):
			if (self.sentTrans[i].reqID == reqID):
				req = self.sentTrans[i]
				del_list.append(req)
				if count_clear != 0:
					output('Using ACK to clear old req ', reqID)
					#count_clear += 1
					#continue
				count_clear += 1
				if req.reqtype == ReqType.Query:
					break
				proc_req = self.procTrans.get(req.reqID)
				if proc_req == None:
					self.procTrans.update({req.reqID:req})
					output("Request "+str(req.reqID)+" has been added to processed transaction")
				elif req.reqtype == proc_req.reqtype:
					output("Duplicate request, don't add to processed transaction")
				else:
					output("Inconsistent With Histroy request, don't add to processed transaction")
		
		for i in range(len(del_list)):
			for j in range(len(self.sentTrans)):
				if del_list[i].reqID == self.sentTrans[j].reqID:
					self.sentTrans.pop(j)
					break

	def search_procTrans(reqID):
		proc_req = self.procTrans.get(reqID)
		if proc_req == None:
			return False
		else:
			return True

	def receive(msg=("REQ", req), from_= src_id):
		self.recTimes += 1
		if (self.recTimes <= self.message_loss or self.message_loss == 0):
			output('Request ' + str(req.reqID) + ' from client received! ')
		else:
			self.recTimes = 0
			return

		if(self.life_time > 0):
			self.life_time = self.life_time-1
			output('The current life_time is: '+ str(self.life_time))
		elif(self.life_time==0):
			output('Server: '+ str(self.serverIP) + ' has expired!')
			sys.exit()		#which causes the server not sending reply back to the client
		
		if req.reqtype != ReqType.Query:
			self.sentTrans.append(req)
			output("Request %s has been added to sent transaction" % req.reqID)

		if (self.next == None):
			ack = Ack(req.reqID, req.reqtype, req.account_num, req.amount)
			result = proc_balance(ack)
			new_balance = result[0]
			outcome = result[1]
			reply = Reply(req.reqID,outcome,new_balance)

			search_result = search_procTrans(req.reqID)
			update_procTrans(req.reqID)
			if search_result == False or (search_result == True and outcome != Outcome.Processed):
				send(('REPLY', reply), to = req.client_id)
				output("Reply for Request "+ str(req.reqID)+" has been sent to client: "+str(req.client_id))
				if (req.reqtype != ReqType.Query):
					send(('ACK', ack), to = prev)
					output(str(ack) + ' has been sent!')
		else:
			send(('REQ', req), to = self.next)

	def receive(msg=("SYNC", req), from_= src_id):
		output('Synchronization of sentTrans from previous server received! ReqID is ', req.reqID)
		if req.reqtype != ReqType.Query:
			self.sentTrans.append(req)
		output("Request %s has been added to sent transaction" % req.reqID)
		if self.next != None:
			send(('SYNC', req), to = self.next)

	def receive(msg=("SYNC_PROC",(reqID,req)), from_ = src_id):
		output('Synchronization of procTrans from the old tail '+str(reqID))
		if req.reqtype != ReqType.Query:
			ack = Ack(req.reqID, req.reqtype, req.account_num, req.amount)
			output(str(ack.reqtype) + ' ' + str(ack.account_num) + ' ' + str(ack.amount))
			self.sentTrans.append(req)
			result = proc_balance(ack)
			update_procTrans(reqID)
			output('Account: ' + str(ack.account_num) + ' New balance is: ' + str(result[0]))
			output(self.AccountInfo)

		if self.next != None:
			send(('SYNC_PROC', (reqID,req)), to = self.next)

	def receive(msg=('ACK', ack), from_= next):
		output(str(ack) + ' has been received!')
		result = proc_balance(ack)
		output('Account: ' + str(ack.account_num) + ' New balance is: ' + str(result[0]))
		update_procTrans(ack.reqID)
		if prev != None:
			send(('ACK', ack), to = prev)

	def receive(msg=("srvFail",(prev,next)), from_ = master):
		self.prev = prev
		self.next = next
		output(" Received SrvFail from Master, Setting my prev to: "+str(self.prev)+" and my next to: "+str(self.next))
		if (self.next != None):
			for i in range(len(self.sentTrans)):
				req = self.sentTrans[i]
				output("Starting synchronize %s sentTrans to next server" % req.reqID)
				send(('SYNC', req), to = self.next)
		else:
			output("I'm the new tail!")

	def receive(msg=("extendChain",newSrv),from_ = master):
		output(str(self.serverIP)+" Received extendChain from master,setting my next to "+str(newSrv))
		self.next = newSrv
		for reqID,req in self.procTrans.items():
			output("Starting synchronize procTrans to the new tail ",reqID)
			send(("SYNC_PROC",(reqID,req)),to = self.next)

	def receive(msg=("new_server_join", newprev), from_ = master):
		output(" I'm the new joined server,setting my prev to "+str(newprev))
		self.prev = newprev
		self.next = None

	def main():
		time.sleep(self.startup_delay)
		output('Server: Bank Name is: '+ str(self.bankName) + '  Server IP is: '+ str(self.serverIP) + '  Life time is: ' + str(self.life_time) + '  Previous server is: ' + str(self.prev) + '  Next server is: ' + str(self.next))
		ping = Ping(self.serverIP,self.bankName)
		while(True):
			if await(False):
				pass
			elif(timeout(1)):
				send(('PING', ping), to = self.master)
			
class Client(process):
	def setup(bankName,account_no,clientIP,input_req,ifRetrans,timeout,nRetrans,ifRandom,time_delay,master,head_srvs,tail_srvs, filename):
		self.bankName = int(bankName)
		self.account_no = account_no
		self.clientIP = clientIP
		self.requests = input_req
		self.ifRetrans = ifRetrans
		self.timeout = timeout
		self.nRetrans = nRetrans
		self.ifRandom = ifRandom
		self.time_delay = time_delay
		self.master = master
		self.head_srvs = head_srvs
		self.tail_srvs = tail_srvs
		self.replyDic = {}
		self.filename = filename
		setup_logfile(self.filename)

	def setup_logfile(filename):
		rootlog = logging.getLogger('')
		filelvl = logging.INFO
		fh = logging.FileHandler(filename)
		formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
		fh.setFormatter(formatter)
		fh.setLevel(filelvl)
		rootlog._filelvl = filelvl
		rootlog.addHandler(fh)	

	def init_req():
		reqList =[]
		client_id = self.id
		if ifRandom == True:
			input_str = input_req[0]
			strs = parse_randomReq(input_str)
			seed_num = strs[0]
			num_req = strs[1]
			prob_query = strs[2]
			prob_deposit = strs[3]
			prob_withdraw = strs[4]
			prob_transfer = strs[5]
			random.seed(seed_num)
			for i in range(num_req):
				a = random.randint(1, 100)
				a = float(a/100)
				amount = random.randint(1, 10) * 100
				if a < prob_query:
					reqtype = ReqType.Query
				elif a < (prob_query + prob_deposit):
					reqtype = ReqType.Deposit
				elif a < (prob_query + prob_deposit + prob_withdraw):
					reqtype = ReqType.Withdraw
				else:
					reqtype = ReqType.Transfer
				reqID = str(self.bankName) + '.'+ str(self.account_no[0]) + '.' + str(i+1)
				req = Request(reqID,reqtype,self.account_no,amount,client_id)
				output('Generating randomized request: '+ str(req))
				reqList.append(req)
		else:
			num_req = len(input_req)
			for i in range(num_req):
				strs = parse_req(input_req[i])
				if strs[0].startswith(str(self.bankName)) and int(strs[2]) == int(self.account_no):
					req = Request(strs[0], strs[1], strs[2], strs[3], client_id)
					reqList.append(req)
				else:
					pass
		return reqList

	def receive(msg=('REPLY', reply), from_= src_id):
		output('Reply received from server: '+ str(reply))

	def receive(msg=("newHead",newSrv),from_= master):
		output("Client setting new head: "+ str(newSrv))
		self.head_srvs.update({self.bankName:newSrv})

	def receive(msg=("newTail",newSrv),from_= master):
		output("Client setting new tail: "+ str(newSrv))
		self.tail_srvs.update({self.bankName:newSrv})

	def receive(msg=("srvFail",newSrv),from_= master):
		output("Client received server fail from Master, starting to sleep.")
		time.sleep(self.time_delay)

	def resend(req):
		times = 0
		while times <= self.nRetrans:
			output("Start retransmitting Request ", req.reqID)
			time.sleep(self.time_delay)
			clk = logical_clock()
			if req.reqtype == ReqType.Query:
				dst = self.tail_srvs.get(self.bankName)
			else:
				dst = self.head_srvs.get(self.bankName)
			send(('REQ', req), to = dst)
			if await(some(received(('REPLY', reply),from_= dst,clk=rclk),has=(rclk>clk))):
				break
			elif some(received(('newTail',newSrv),from_= master,clk=rclk),has=(rclk>clk)):
				times = 0
				#output('Master notification received, do not minus Retrans')
				continue
			elif timeout(self.timeout):
				times += 1
		output('Retransmit time equals the RetransLimit, stop retransmitting Request '+str(req.reqID))

	def main():
		output('Client: Bank Name is: '+str(self.bankName)+ '  Account number is: '+ str(self.account_no))
		reqList = init_req()
		replyNum = 0
		num_req = len(reqList)
		for i in range(num_req):
			req = reqList[i]
			if req.reqtype == ReqType.Query:
				dst = self.tail_srvs.get(self.bankName)	
			else:
				dst = self.head_srvs.get(self.bankName)
			output('Request ' + str(req.reqID) + ' has been sent out')
			time.sleep(self.time_delay)
			clk = logical_clock()
			send(('REQ', req), to = dst)
			if await(some(received(('REPLY', reply),from_= dst,clk=rclk),has=(rclk>clk))):
				replyDic.update({reply.reqID:reply})
				continue
			elif timeout(self.timeout):
				output('Client waiting for reply '+str(req.reqID)+' TIMEDOUT!')
				resend(req)
		while(len(replyDic)<num_req):
			clk = logical_clock()
			if await(some(received(('REPLY', reply),from_= dst,clk=rclk),has=(rclk>clk))):
				replyDic.update({reply.reqID:reply})
				continue
			else:
				pass
		output("All request has been sentout, client exits")

def main():
	srvDic = collections.defaultdict(list)
	cliDic = collections.defaultdict(list)
	waitList =[]
	head_srvs ={}
	tail_srvs ={}
	config(channel='fifo',handling='all',clock='Lamport')
	flag_srv =False
	flag_cli =False
	flag_req =False
	flag_config =False
	input_srv =[]
	input_cli =[]
	input_req =[]
	config_file = None
	if len(sys.argv) < 2:
		print('Please input config file!')
		sys.exit()
	else:
		config_file = sys.argv[1]
	fp = open(config_file,'r')
	for line in fp:
		if line.startswith('//Server'):
			flag_srv =True
			continue
		elif line.startswith('//Client '):
			flag_config =True
			input_str = fp.__next__()
			list_config = parse_config(input_str)
			continue
		elif line.startswith('//Client:'):
			flag_cli =True
			continue
		elif line.startswith('//Request'):
			flag_req =True
			continue
		elif flag_srv==True and flag_config==False:
			input_srv.append(line)
		elif flag_cli==True and flag_req==False:
			input_cli.append(line)
		elif flag_req==True and line!='\n':
			input_req.append(line)
		else:
			pass

	srvList =[]
	for string in input_srv:
		srv = parse_server(string)
		srvList.append(srv)

	num_srv = len(input_srv)
	servers = list(new(Server, num = num_srv))
	bankName_srv = []
	serverIP = []
	startup_delay = []
	life_time = []
	message_loss = []

	for i in range(num_srv):
		bankName_srv.append(srvList[i][0])
		serverIP.append(srvList[i][1])
		startup_delay.append(srvList[i][2])
		life_time.append(srvList[i][3])
		message_loss.append(srvList[i][4])

	for i in range(num_srv):
		if i == 0 or bankName_srv[i]!= bankName_srv[i-1]:
			prev = None
		else:
			prev = servers[i-1]
		if i == num_srv - 1 or bankName_srv[i]!= bankName_srv[i+1] or startup_delay[i+1] != 0:
			next = None
		else:
			next = servers[i+1]
		if prev == None and startup_delay[i] == 0:
			head_srvs.update({bankName_srv[i]:servers[i]})
		elif next == None and startup_delay[i] == 0:
			tail_srvs.update({bankName_srv[i]:servers[i]})
		if startup_delay[i] == 0:
			srvDic[bankName_srv[i]].append([servers[i],prev,next,serverIP[i]])
		else:
			waitList.append([bankName_srv[i],servers[i],prev,next,serverIP[i]])


	cliList =[]
	for string in input_cli:
		cli = parse_client(string)
		cliList.append(cli)

	num_cli =len(input_cli)
	clients = list(new(Client, num = num_cli))
	bankName_cli =[]
	account_no =[]
	clientIP =[]
	ifRetrans = list_config[0]
	timeout = list_config[1]
	nRetrans = list_config[2]
	ifRandom = list_config[3]
	time_delay = list_config[4]

	for i in range(num_cli):
		bankName_cli.append(cliList[i][0])
		account_no.append(cliList[i][1])
		clientIP.append(cliList[i][2])

	for i in range(num_cli):
		cliDic[bankName_cli[i]].append(clients[i])

	#######################Initiate Master#################################
	filename_master = './master_log'
	filename_server = './server/server_log'
	filename_client = './client/client_log'
	master = new(Master)
	setup(master,(srvDic, cliDic, filename_master, waitList))
	start(master)
	#######################################################################

	#######################Initiate Servers################################
	for i in range(num_srv):
		server_name = filename_server + str(i + 1)
		if i == 0 or bankName_srv[i]!= bankName_srv[i-1]:
			prev = None
		else:
			prev = servers[i-1]
		if i == num_srv - 1 or bankName_srv[i]!= bankName_srv[i+1] or startup_delay[i+1] != 0:
			next = None
		else:
			next = servers[i+1]
		setup(servers[i],(bankName_srv[i], serverIP[i], startup_delay[i], life_time[i], message_loss[i], prev, next, master, server_name))
	
	start(servers)

	#######################Initiate Clients################################
	for i in range(num_cli):
		client_name = filename_client + str(i + 1)
		setup(clients[i], (bankName_cli[i], account_no[i], clientIP[i], input_req, ifRetrans, timeout, nRetrans, ifRandom, time_delay, master,head_srvs,tail_srvs, client_name))

	start(clients)
	#######################################################################
	
